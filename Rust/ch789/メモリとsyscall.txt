◆メモリ領域は４種類ある

┏━━━━━━━━━┓
┃  Heap   ┃　->　可変長データ（String、Vector）
┣━━━━━━━━━┫
┃  Stack  ┃　->　固定長の変数や配列
┣━━━━━━━━━┫
┃  Static ┃　->　const、文字リテラルに実体
┣━━━━━━━━━┫
┃  Text   ┃　->　バイナリファイル
┗━━━━━━━━━┛


Hello World! を出力した場合、この文字列はどのようなプロセスで表示されるか？
　１．ソースコードをマシン後にコンパイルしたバイナリファイルが作成（.exe）　catコマンドで確認可能
　２．実行時にOSがバイナリファイルを読み取り、メモリにコピーする
　３．メモリからコマンドプロンプトやターミナルに文字を表示するには、OSのsystem callを利用して表示する
　４．OSはwrite()というsystem callがあるが、これをそのまま実行使用するとassemblyなどが出てきて大変なので
　　　実際はC言語のライブラリである「libc」のwrite()関数を使用する。（libcのwrite関数が内部的にのwrite syscallを行う）

libcのwrite()について、
　write(fd, buf, size)　…fdはfile discripterで標準出力で「１」
　　　　　　　　　　　　　…bufはバッファーへのポインタ(メモリアドレス{:p})
　　　　　　　　　　　　　…sizeは何文字出力するか？

strace　./target/debug/Hello で確認可能。

※catコマンドやstraceコマンドはWindowsでは存在しないので、WSLやUNIX OSの機能を提供するツールなどをダウンロードする

===================================================================================================================================

◆メモリの論理的な姿
┏━━━━━━━━━━━━━━━━━━━━━━━━━━━┓ 0x00...0
┃                           ┃
┃                           ┃　　　　　　　　　　　Heapはメモリアドレスが小さい方から確保される
┃                           ┃　　　　　　　　　　　　　-> 可変長は要するメモリサイズが変動するため、固定長に合わせて詰めない
┃                           ┃　　　　　　　　　　　　　-> そのため、メモリサイズが変動した時に追加でサイズを確保できるようにStack、Staticと隣接しない領域で確保される
┃                           ┃
┃                           ┃
┃                           ┃
┃                           ┃
┃                           ┃　　　　　　　　　　　StackやStaticはメモリアドレスが大きい方から確保される
┃                           ┃　　　　　　　　　　　　　-> 固定長は要するメモリサイズが決まっているため
┗━━━━━━━━━━━━━━━━━━━━━━━━━━━┛ 0xFF...F

C関数のmalloc()がHeapの中からいい感じのサイズを確保してくる
malloc()した領域はfree()しないといけない（２回free()をすると事故る）　※この辺はC言語の難解ポイント
　　↓
Rustでは上記を自動で解決するために所有権を搭載している


C言語では、 S = malloc()
           S.free() で確保、解放を行う

Rustでは、　Sに対して管理責任が生じ、この責任ごと値は参照される

===================================================================================================================================

◆所有権について
例として、
fn f() {
    let s = String::from("hey");
    // do something
    println!("{s}");
    // freeされる
}

fn main() {
    f();
    println!("Hello world!");
}

■■■Stringの中身
　※この構造体は説明用の書き方です。本来の書式とは異なります。
struct String {
    pointer : *     // malloc()からもらったやつ　　　　　　　　　64ビット整数
    len     : usize // capacityのうち、実際に使用しているサイズ　64ビット整数
    capacity: usize // malloc()が確保した領域のサイズ　　　　　　64ビット整数
}


スタックには64bit x 3 = 192bit(24bytes)確保している。
しかし、pointerが指し示す先はヒープ領域にある。
つまり、スタック領域のpointer分の64bitはヒープ領域へのアドレスを格納するだけで、実体となるデータはヒープ領域に確保された領域に格納される。

　　　【スタックメモリ】　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　【ヒープ領域】
┃                           ┃　　　　　　　　　　　　　　　　　　　　　　　　　　　┃                           ┃　
┃                           ┃　　　　　　　　　　　　　　　　　　　　　　　　　　　┃         "hey"             ┃free()される
┃                           ┃　　　　　　　　　　　　　　　　　　　　　　　　　　　┃                           ┃
┣━━━━━━━━━━━━━━━━━━━━━━━━━━━┫ 　　　　　　　　　　　　　　　　　　　　　　　　　　 ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━┛
┃                           ┃-> f()の中の、s = String::from("hey");の領域
┃                           ┃　　　struct Stringの３要素が格納されている　　　　　　　　　　　　↑struct String { pointer }が指す先
┃                           ┃
┣━━━━━━━━━━━━━━━━━━━━━━━━━━━┫ 
┃                           ┃-> main関数のための領域
┗━━━━━━━━━━━━━━━━━━━━━━━━━━━┛




・所有権がMoveしてエラーが発生することを確認してみよう。
------------------------------------------
let s = String::from("hey");
let t = s;        // Ownership is Move
println!("{s}");  // ★ Error ★
------------------------------------------

なお、引数でも所有権はMoveする
------------------------------------------
fn g(t: String) {
    println!("{t}"); 
}

fn f() {
    let s = String::from("hey");
    g(s);
    println!("{s}");    // ★ Error ★ 所有権はg()の引数tにMoveしている
}
------------------------------------------


上記を解決するために使用するのが、「所有権の借用」
------------------------------------------
fn g(t: &str) {
    println!("{t}"); 
}

fn f() {
    let s = String::from("hey");
    g(&s);
    println!("{s}");    // Errorは起きない！
}
------------------------------------------
&…借用の記号！（Goの&とはまたイメージが少々異なるので注意）

■■■&strの中身
　※この構造体は説明用の書き方です。本来の書式とは異なります。
struct &str {
    pointer: 64bit
    len    : 64bit
}

※Stringにはcapacityがあるのに、&strにはcapacityがない理由
　Stringのcapacityが1024byteのヒープ領域を確保して、「heyheyheyheyhey...」と続きヒープ領域が不足したら
　よりサイズの大きいヒープ領域（2048byteなど）を確保して、そちらに「heyheyhey...」をコピーしてpointerを繋ぎ変える
　一方、&strは借用するもと（借りるもの）なので、借りてる身で勝手にStringのように容量を増やしてpointerの参照先を変えたりなどはできない。
　よって、&strはcapacityを持たない。

　pointerはあくまでヒープ領域の格納先の先頭しか分からないため、lenはpointer先から逆算できない。（lenは要は末尾までを示す）
　&strにもlenがあることでバッファオーバーランの脆弱性を回避できる。

ちなみに、書き換えはコンパイルエラーが発生する。
fn f() {
    let mut s = String::from("hey");
    let t = &s;
    s.push_str("yo");
    println!("s:{s}, t:{t}");    // ★ Error ★　tはsから借りてる身なんだから勝手に変えるな
    // 上記をprintln!("s:{s});にするとtはこのブロックが終わるまで使用してないから156行目の前にtはsに返したと認識する（賢い）
    // よって、println!("s:{s});は"heyyo"と出力する
}


◆Lifetime
スタックの底の方が長命、上が短命。
　　　【スタックメモリ】              　　　【スタックメモリ】　       　　　【スタックメモリ】　　
┃                           ┃      
┃         g                 ┃      
┃                           ┃                                            ※新しい変数などはスタックで詰まれ
┣━━━━━━━━━━━━━━━━━━━━━━━━━━━┫      ┣━━━━━━━━━━━━━━━━━━━━━━━━━━━┫           先に開放されていくので
┃                           ┃  =>  ┃                           ┃  =>  　　　底に近いほど長命となる
┃        f                  ┃      ┃        f                  ┃
┃                           ┃      ┃                           ┃
┣━━━━━━━━━━━━━━━━━━━━━━━━━━━┫      ┣━━━━━━━━━━━━━━━━━━━━━━━━━━━┫      ┣━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
┃       main                ┃      ┃       main                ┃      ┃       main                ┃
┗━━━━━━━━━━━━━━━━━━━━━━━━━━━┛      ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━┛      ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━┛


------------------------------------------
fn g() -> &str {
    let t = String::from("yo");
    &t  // 戻り値
}

fn f() {
    let t = g();  // ★ Error ★厳密には上のg()でエラーが発生する
    println!("{t}");
}
------------------------------------------
f()とg()では、g()の方が短命であり、自分より長命のf()に貸し出すことはできない。
　→先にg()が死に、ヒープがfree()されると、&strで受け取ったpointerが指し示す先が無くなるから。
        g() Stringなのでpointer、len、capacity
        f() ではlet t = g();で、g()の戻り値tを&strの形で受け取っている（pointer、len）
        そしてg()は戻り値（&t）を返すと寿命を迎えて死ぬが、その時にスタック領域と実体のあるヒープ領域を解放するため、&str型で受け取ったtが参照する先が無くなる。

ちなみに上記をコンパイルすると、戻り値の型指定を、-> &'static strにしろと言われるが、そのように修正したところで無理（スタックの話より）
ではどうするか？　正解は、&strではなくStringを戻り値の型指定に使う。
------------------------------------------
fn g() -> String {
    let t = String::from("yo");
    t  // 戻り値
}

fn f() {
    let t = g();  // Errorが発生しなくなる（g()で作成したtをf()のtが受け取った際に、String型で受け取っているため借用ではなくMoveで受け取ったため）
    println!("{t}");
}
------------------------------------------
１．f()側のlet t = g();で先にf()の変数tのスタック領域を確保しておく（先にいうとString型が返ってくるので24byte確保する）
２．g()側のlet t = String::from("yo");でg()の変数t分の24byteを更にスタック領域に確保する
３．f()側で呼び出したg()の実行が完了するとg()は死にスタック領域とpointerが指すヒープ領域が解放されるが、
　　f()の変数tはg()の変数tの所有権を譲渡（Move）されているので、g()が死んでメモリが解放されても参照先が無くならないためエラーは発生しない



